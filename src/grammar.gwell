head: ${
    export const TYPES = {
        Operation: 'operation',
        Default: 'default',
        Logical: 'logical',
        Assignment: 'assignment',
        Declare: 'declare',
        Control: 'control',
        Conditional: 'conditional',
        Loop: 'loop',
        Literal: 'literal',
        Array: 'array',
        Object: 'object',
        Lambda: 'lambda',
        Reference: 'reference',
        Query: 'query',
        Run: 'run',
        Call: 'call',
        Match: 'match',
        Spread: 'spread',
        Cluster: 'cluster',
        Constant: 'constant',
        Wildcard: 'wildcard',
        Yield: 'yield',
        Word: 'word'
    }
}

lexer: {{
    mc_root ->
        - import: mc_keywords
        - when: /"/ tag: "dquote" highlight:"string" goto: mc_dqstring 
        - when: /'/ tag: "squote" highlight:"string" goto: mc_sqstring 
        - when: /\d+/ tag: "digits" highlight: "number"
        - when: /[_a-zA-Z$][_a-zA-Z$\d]*/ tag: "word"
        - when: "=>" tag: "l_arrow" highlight: "keyword"
        - when: "!=" tag: "l_arrow" highlight: "keyword"
        - when: "==" tag: "l_eqeq" highlight: "keyword"
        - when: ">=" tag: "l_gteq" highlight: "keyword"
        - when: "<=" tag: "l_lteq" highlight: "keyword"
        - when: "+=" tag: "l_add" highlight: "keyword"
        - when: "-=" tag: "l_sub" highlight: "keyword"
        - when: "/=" tag: "l_div" highlight: "keyword"
        - when: "%=" tag: "l_mod" highlight: "keyword"
        - when: "*=" tag: "l_mul" highlight: "keyword"
        - when: "..." tag: "l_spread" highlight: "keyword"
        - when: ".." tag: "l_concat" highlight: "keyword"
        - when: "=" tag: "l_eq"
        - when: ">" tag: "l_gt" highlight: "keyword"
        - when: "<" tag: "l_lt" highlight: "keyword"
        - when: "+" tag: "l_add" highlight: "keyword"
        - when: "-" tag: "l_sub" highlight: "keyword"
        - when: "/" tag: "l_div" highlight: "keyword"
        - when: "%" tag: "l_mod" highlight: "keyword"
        - when: "*" tag: "l_mul" highlight: "keyword"
        - when: "?" tag: "l_qmark" highlight: "keyword"
        - when: "^" tag: "l_exp" highlight: "keyword"
        - when: ";" tag: "l_semi" highlight: "keyword"
        - when: ":" tag: "l_col" highlight: "keyword"
        - when: "!" tag: "l_exc" highlight: "keyword"
        - when: "." tag: "l_dot"
        - when: "," tag: "l_comma" highlight: "delimiter"
        - when: "(" tag: "l_lparen" highlight: "delimiter" inset
        - when: ")" tag: "l_rparen" highlight: "delimiter" pop
        - when: "{" tag: "l_lcurly" highlight: "delimiter" inset
        - when: "}" tag: "l_rcurly" highlight: "delimiter" pop
        - when: "[" tag: "l_lbrack" highlight: "delimiter" inset
        - when: "]" tag: "l_rbrack" highlight: "delimiter" pop
        - when: /\s+/ tag: "ws"

    mc_keywords ->
        - when: /\@/ tag: "keyword" highlight: "keyword"
        - when: /set(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /var(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /const(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /asc(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /desc(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /function(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /true(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /false(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /null(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /any(?![a-zA-Z])/ tag: "keyword","word" highlight: "keyword"
        - when: /all(?![a-zA-Z])/ tag: "keyword","word" highlight: "keyword"
        - when: /within(?![a-zA-Z])/ tag: "keyword","word" highlight: "keyword"
        - when: /between(?![a-zA-Z])/ tag: "keyword","word" highlight: "keyword"
        - when: /and(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /or(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /on(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /if(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /match(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /default(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /in(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /else(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /for(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /like(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /not(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /while(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /until(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /to(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /do(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /run(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /return(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"

        - when: /query(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /scan(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /segment(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /filter(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /sort(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /aggregate(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /cluster(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"

        - when: /list(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        - when: /first(?![a-zA-Z])/ tag: "keyword" highlight: "keyword"
        
    mc_dqstring ->
        - when: /\\[\\\/bnrft]/ tag: "escaped" highlight:"constant"
        - when: /\\"/ tag: "quoteEscape"
        - when: /\\u[A-Fa-f\d]{4}/ tag: "escaped" highlight:"constant"
        - when: /\\./ tag:"badEscape"
        - when: /[^"\\]+/ tag: "string" highlight:"string"
        - when: "\"" tag: "dquote" highlight:"string" pop

    mc_sqstring ->
        - when: /\\[\\\/bnrft]/ tag: "escaped"
        - when: /\\'/ tag: "quoteEscape"
        - when: /\\u[A-Fa-f\d]{4}/ tag: "escaped" 
        - when: /\\./ tag:"badEscape"
        - when: /[^'\\]+/ tag: "string" highlight:"string"
        - when: "'" tag: "squote" highlight:"string" pop

}}

grammar: {{
    // Uncomment the line below to allow experimental diagram generation
	// postprocessorOverride: ${ _ => _ }

    MC_Body ->
         _ MC_Statements _  : {{ { statements: $1} }}
        | _ MC_Exp _ : {{ { expression: $1} }}

    MC_Statements -> 
        MC_Statement : {{ [$0] }}
        | MC_Statements _ MC_Statement : {{ ( $2.type == 'declare' &&  $2.kind =='function'? $0.unshift($2): $0.push($2)) && $0 }} // Hoist Functions

    MC_Statement ->
        MC_Assignment : {{ $0 }}
        | MC_DeclareVar : {{ $0 }}
        | MC_DeclareFunction : {{ $0 }}
        | MC_Return : {{ $0 }}
        | MC_IfBlock : {{ { type: TYPES.Conditional, statements: $0 } }}
        | MC_IfBlock _ "else" _ MC_Block : {{  { type: TYPES.Conditional, statements: $0.concat([{ condition: null, statements: $4 }])} }}
        | MC_ScanBlock : {{ $0 }}
        | MC_ConditionLoop : {{ $0 }}
        | MC_LoopBlock : {{ $0 }}
        | "run" __ MC_Exp _ ";" : {{ { type: TYPES.Run, expression: $2 }}}

    MC_Assignment ->
        MC_Reference _ "=" _ MC_Exp _ ";" : {{ { type: TYPES.Assignment, reference: $0,  value: $4 } }}
        | "set" __ MC_Reference _ "=" _ MC_Exp _ ";" : {{ { type: TYPES.Assignment, reference: $2,  value: $6 } }}

    MC_Assignment : {{ { type: TYPES.Assignment, reference: $0,  value: { type: TYPES.Operation, operator: $2.value[0], operands: [$0, $4] } } }} ->
         MC_Reference _ "+=" _ MC_Exp _ ";"
        | MC_Reference _ "-=" _ MC_Exp _ ";"
        | MC_Reference _ "/=" _ MC_Exp _ ";"
        | MC_Reference _ "*=" _ MC_Exp _ ";"
        | MC_Reference _ "%=" _ MC_Exp _ ";"

    MC_DeclareVar ->
        "var" __ MC_Word _ "=" _ MC_Exp _ ";" : {{ { type: TYPES.Declare, kind: 'var', name: $2, value: $6 } }}
        | "const" __ MC_Word _ "=" _ MC_Exp _ ";" : {{ { type: TYPES.Declare, kind: 'const', name: $2, value: $6 } }}

    MC_Return ->
        "return" _ MC_Exp:exp _ ";" : {{ { type: TYPES.Control, kind: "return", value: $exp } }}
    
    MC_DeclareFunction ->
        "function" _ MC_Word:name _ "(" _ MC_FunctionArg_list:args _ ")" _ MC_Block:block : {{ { type: TYPES.Declare, kind: 'function', name: $name, args: $args, statements: $block } }}
        | "function" _ MC_Word:name _ "(" _ ")" _ MC_Block:block : {{ { type: TYPES.Declare, kind: 'function', name: $name, args: [], statements: $block } }}

    MC_IfBlock ->
        "if" _ MC_Exp _ MC_Block : {{ [{ condition: $2, statements: $4 }] }}
        | MC_IfBlock _ "else" _ MC_IfBlock : {{ $0.concat($4) }}

    MC_ScanBlock ->
        "scan" __ MC_KVInIterator:kv _ MC_Block:block : {{ { type: TYPES.Loop, kind: 'scan', ...$kv, statements: $block } }}

    MC_KVInIterator -> 
        MC_Word:value __ "in" _ MC_Exp:exp : {{ { v: $value, iterable: $exp } }}
        |  MC_Word:value _ "," _ MC_Word:key __ "in" _ MC_Exp:exp : {{ { k: $key, v: $value, iterable: $exp } }}

    MC_ConditionLoop ->
       "while" _ MC_Exp:condition _ MC_Block:block : {{ { type: TYPES.Loop, kind:'while', condition: $condition, statements: $block } }}
        | "until" _ MC_Exp:condition _ MC_Block:block : {{ { type: TYPES.Loop, kind:'while', condition: { type: TYPES.Operation, operator: "!", operands: [$condition] }, statements: $block } }}
        | "do" _ MC_Block:block __ "while" _ MC_Exp:condition : {{ { type: TYPES.Loop, kind:'while', condition: $condition, statements: $block } }}
        | "do" _ MC_Block:block __ "until" _ MC_Exp:condition : {{ { type: TYPES.Loop, kind:'while', condition: { type: TYPES.Operation, operator: "!", operands: [$condition] }, statements: $block } }}

    MC_LoopBlock ->
        "for" _ "(" _ MC_DeclareVar:base  _ MC_Exp:condition _ ";" _ MC_Assignment:step _ ")" _ MC_Block:block : {{ { type: TYPES.Loop, kind:'for', base: $base, step: $step, condition: $condition, statements: $block } }}

    MC_Block -> "{" _ MC_Statements _ "}" : {{ $2 }}
        | "{" _ "}" : {{ [] }}

    MC_Exp_list -> MC_Exp : {{ [ $0 ] }}
        | MC_Exp_list _ "," _ MC_Exp : {{ $0.concat($4) }}

    MC_Exp_ss -> MC_Exp : {{ [ $0 ] }}
        | MC_Exp_ss _ ";" _ MC_Exp : {{ $0.concat($4) }}

    MC_Exp : {{ $0 }} ->
        MC_Query
        | MC_Lambda
        | MC_ExpOr
        | MC_Object

    MC_ExpOr ->
        MC_ExpOr _ "or" _ MC_ExpAnd : {{ { type: TYPES.Logical, operator: "any", operands: [$0, $4] } }} 
        | MC_ExpAnd : {{ $0 }}

    MC_ExpAnd ->
         MC_ExpAnd _ "and" _ MC_ExpCompare  : {{ { type: TYPES.Logical, operator: "all", operands: [$0, $4] } }}
        | MC_ExpCompare : {{ $0 }}

    MC_ExpCompare : {{ { type: TYPES.Operation, operator: $2.value, operands: [$0, $4] } }} ->
        MC_ExpCompare _ "<"  _ MC_ExpConcat
        | MC_ExpCompare _ ">"  _ MC_ExpConcat
        | MC_ExpCompare _ "<=" _ MC_ExpConcat
        | MC_ExpCompare _ ">=" _ MC_ExpConcat
        | MC_ExpCompare _ "!=" _ MC_ExpConcat
        | MC_ExpCompare _ "==" _ MC_ExpConcat
        | MC_ExpCompare _ "like" _ MC_ExpConcat
        | MC_ExpCompare _ "within" _ MC_Range : {{ { type: TYPES.Operation, operator: $2.value, operands: [$0, $4.low, $4.high] } }}
        | MC_ExpCompare _ "between" _ MC_Range : {{ { type: TYPES.Operation, operator: $2.value, operands: [$0, $4.low, $4.high] } }}
        | MC_ExpConcat : {{ $0 }}

    MC_ExpConcat : {{ { type: TYPES.Operation, operator: $2.value, operands: [$0, $4] } }} ->
        MC_ExpSum _ ".." _ MC_ExpConcat
        | MC_ExpSum : {{ $0 }}

    MC_ExpSum : {{ { type: TYPES.Operation, operator: $2.value, operands: [$0, $4] } }} ->
        MC_ExpSum _ "+" _ MC_ExpProduct
        | MC_ExpSum _ "-" _ MC_ExpProduct
        | MC_ExpProduct : {{ $0 }}

    MC_ExpProduct : {{ { type: TYPES.Operation, operator: $2.value, operands: [$0, $4] } }} ->
        MC_ExpProduct _ "*" _ MC_ExpUnary
        | MC_ExpProduct _ "/" _ MC_ExpUnary
        | MC_ExpProduct _ "%" _ MC_ExpUnary
        | MC_ExpUnary : {{ $0 }}

    MC_ExpUnary : {{ { type: TYPES.Operation, operator: "!", operands: [$2] } }} ->
        "!" _ MC_ExpPower
        | "not" _ MC_ExpPower
        | MC_ExpPower : {{ $0 }}

    MC_ExpPower ->
        MC_Atom _ "^" _ MC_ExpPower : {{ { type: TYPES.Operation, operator: $2.value, operands: [$0, $4] } }}
        | MC_Atom : {{ $0 }}

    MC_Atom : {{ $0 }} ->
        MC_Number
        | MC_NegativeNumber
        | MC_String
        | MC_Constant
        | MC_Regex
        | MC_Reference
        | MC_Group
        | MC_FunctionCall
        | MC_Array
        | MC_VariadicLogic
        | MC_Match

    MC_Constant : {{ { type: TYPES.Constant, value: $0.value } }} ->
        "null"
        | "false"
        | "true"

    MC_Reference ->
        MC_Path   : {{  { type: TYPES.Reference, path: $0 } }}

    MC_Path ->
        MC_Word : {{ [{ type: TYPES.Word, value: $0 }] }}
        | MC_Path _ "." _ MC_Word : {{ $0.concat({ type: TYPES.Word, value: $4}) }}
        | MC_Path _ "[" _ MC_Exp _ "]" : {{ $0.concat($4) }}
        | MC_Path _ "[" _ "?" _ "]" : {{ $0.concat({ type: TYPES.Wildcard }) }}

    MC_Word -> $word : {{ $0.value }}

    MC_Group -> "(" _ MC_Exp _ ")" : {{ $2 }}

    MC_Number ->
        $digits "." $digits : {{ { type: TYPES.Literal, kind: 'number', value: $0.value  + "." + $2.value } }}
        | $digits : {{ { type: TYPES.Literal, kind: 'number', value: $0.value } }}

    MC_NegativeNumber ->  "-" _ MC_Number : {{ { type: TYPES.Literal, kind: 'number', value: '-' +$2.value } }}
    
    MC_String : {{ { type: TYPES.Literal, kind: 'string', value: $1 } }} 
        -> $dquote MC_StringInner $dquote 
        | $squote MC_StringInner $squote

    MC_String : {{ { type: TYPES.Literal, kind: 'string', value: '' } }}
         -> $dquote $dquote
        | $squote $squote

    MC_StringInner -> MC_StringEscape : {{ $0 }}
        | $string : {{  $0.value }}
        | MC_StringInner MC_StringEscape : {{ $0 + $1 }}
        | MC_StringInner $string : {{ $0 + $1.value }}
    
    MC_StringEscape -> $escaped : {{  JSON.parse('"' +$0.value + '"') }}
        | $quoteEscape : {{ $0.value[1] }}

    MC_Array -> "[" _ "]" : {{ { type: TYPES.Array, items: [] } }}
        | "[" _ MC_Exp_list _ "]" : {{ { type: TYPES.Array, items: $2 } }}

    MC_Object -> "{" _ "}" : {{ { type: TYPES.Object, properties: [] } }}
        | "{" _ MC_Prop_list _ "}" : {{ { type: TYPES.Object, properties: $2 } }}

    MC_Prop_list -> MC_Prop : {{ [$0] }}
        | MC_Prop_list _ "," _ MC_Prop : {{ $0.concat($4) }}

    MC_Prop -> MC_PropName _ ":" _ MC_Exp : {{ { key: $0, value: $4 } }}
        | "..." _ MC_Exp : {{ { type: TYPES.Spread, value: $2 } }}
        | MC_Word : {{ { key: $0, value: { type: TYPES.Reference, path: $0 } } }}

    MC_Query -> MC_QQuery ( __ MC_QFilter)? __ MC_QYield ( __ MC_QCluster)? ( __ MC_QSort)?  ( __ MC_QSlice)? : {{ { type: TYPES.Query,  source: $0, filter: $1?.[1], yield: $3, cluster: $4?.[1], sort: $5?.[1],  slice: $6?.[1] } }}

    MC_QQuery : {{ { kind:$0.value, iterable: $2 } }} 
        -> "query" __ MC_KVInIterator 

    MC_QSort -> "sort" __ MC_Exp ( __ "desc"|"asc")? : {{ { expression: $2, direction: $3?.[1].value } }}

    MC_QFilter -> "filter" __ MC_Exp : {{ $2 }}

    MC_QYield : {{ { type: TYPES.Yield, kind: $0.value, value: $2 } }} 
        ->  "list" __ MC_Exp
        | "first" __ MC_Exp
        | "aggregate" _ MC_Object
        | "aggregate" __ MC_Lambda

    MC_QCluster -> "cluster" __ "(" _ MC_Exp_list _ ")" : {{ $4 }}

    MC_QSlice -> "segment" __ MC_Range : {{ $2 }}

    MC_Range ->  MC_Exp _ "to" _ MC_Exp : {{ { low: $0, high: $4 } }}

    MC_Alias -> MC_Reference : {{ $0 }}
        | MC_Reference __ "as" __ MC_Word : {{ { ...$0, alias: $4 } }}
        | MC_Reference __ MC_Word  : {{ { ...$0, alias: $2 } }}

    MC_Alias_list -> MC_Alias : {{ [$0] }}
        | MC_Alias_list _ "," _ MC_Alias : {{ $0.concat($4) }}

    MC_Lambda -> "(" _ MC_FunctionArg_list _ ")" _ "=>" _ MC_Exp:expression : {{ { type: TYPES.Lambda, arguments: $2, expression: $expression  } }}
        | "(" _ ")" _ "=>" _ MC_Exp:expression : {{ { type: TYPES.Lambda, arguments: $2, expression: $expression  } }}
        | MC_Word _ "=>" _ MC_Exp:expression : {{ { type: TYPES.Lambda, arguments: $2, expression: $expression  } }}

    MC_FunctionArg -> MC_Word : {{ { name: $0 } }}
        | MC_Word _ "=" _ MC_Exp : {{ { name: $0, default: $4 } }}

    MC_FunctionArg_list -> MC_FunctionArg : {{ [$0] }}
        | MC_FunctionArg_list _ "," _ MC_FunctionArg : {{ $0.concat($4) }}

    MC_PropName : {{ $0 }} -> MC_String | MC_Word 

    MC_FunctionCall -> MC_Word:name _ "(" _ MC_Exp_list:args _  ")" : {{ { type: TYPES.Call, name: $name, args: $args } }}
        | MC_Word:name _ "(" _ ")" : {{ { type: TYPES.Call, name: $name, args: [] } }}

    MC_VariadicLogic : {{ { type: TYPES.Logical, operator: $0.value, operands: $4 } }}
        -> "any" _ "{" _ MC_Exp_ss _  ( ";" _ )? "}"
        | "all" _ "{" _ MC_Exp_ss _ ( ";" _ )? "}"

    MC_Match -> "match" _ "{" _ MC_MatchStatement_list _ "}" : {{ { type:TYPES.Match, statements: $4 } }}

    MC_MatchStatement -> MC_Exp _ ":" _ MC_Exp _  ";" : {{ { condition: $0, value: $4 } }}
        | "default" _ ":" _ MC_Exp _ ";" : {{ { type: TYPES.Default , value: $4 } }}

    MC_MatchStatement_list -> MC_MatchStatement : {{ $0.type == TYPES.Default ? ({ default: $0, conditions: [] }) : ({ conditions: [$0] }) }}
        | MC_MatchStatement_list _ MC_MatchStatement : {{ ($2.type == TYPES.Default ? $0.default = $2 : $0.conditions.push($2)) && $0  }}

    _ -> $ws? : {{ null }}
    __ -> $ws : {{ null }}
}}